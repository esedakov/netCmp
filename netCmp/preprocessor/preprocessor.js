/**
	Developer:	Eduard Sedakov
	Date:		2016-01-15
	Description:	pre-process lexed code to identify all TTUs (Templated
					Type Usage = TTU) so that parser could create as many 
					templated types as there are use cases for such types.
					Example, if code has type 'foo' that takes two templates:
					code exmaple: 'object <_Ty,_Ky> foo { ... }'
					and inside code there are two various usage cases of 'foo'
					such as these: 'foo<int, real>' and 'foo<text, text>'
					then we would store two TTUs for type 'foo':
					1. <int, real>
					2. <text, text>
					and during parsing we would create two separate instances
					of type 'foo' for each mentioned TTU.
	Used by:		{parser}
	Dependencies:	{parser}, {lexer}
**/

//class pre-processor that is needed to find and store various TTUs
//input(s):
//	tokens: (Array<Token>) array of tokens generated by the lexer
//output(s):
//	(HashMap< string, Array<Array<text>> >) =>
//		hashmap's key (string) represents a name of templated type, e.g. 'foo'
//		hashmap's value stores two arrays:
//			outer array stores actual TTUs, while inner elements of each TTU
//Example for above: { 'foo' : [['int', 'real'], ['text', 'text']] }
function preprocessor(tokens){
	//initialize return variable
	var ret = {};
	//loop thru tokens
	for( var i = 0; i < tokens.length; i++ ){
		//determine if current token is an open angle bracket (i.e. '<')
		if( tokens[i].type == TOKEN_TYPE.LESS ){
			//what we need is an identifier before angle bracket
			//	which is the name of the type
			var tmpTypeToken = tokens[i-1];
			//make sure that type token is a TEXT
			if( tmpTypeToken.type != TOKEN_TYPE.TEXT ){
				//skip, this is not a template definition
				continue;
			}
			//get presumably a type name (still there is a big chance it
			//is not a template usage case)
			var tmpTypeName = tmpTypeToken.text;
			//declare array to store elements of single TTU
			var tmpTTUElems = [];
			//loop thru consequent tokens till either:
			//	1. closing angle bracket is found (i.e. '>') => means, 
			//		this is a template usage case
			//	2. or, we find a token other then TEXT and COMMA => means,
			//		this is not a template, so skip
			var j = i + 1;
			while( tokens[j].type == TOKEN_TYPE.TEXT || 
					tokens[j].type == TOKEN_TYPE.COMMA ){
				//if this is a TEXT token
				if( tokens[j].type == TOKEN_TYPE.TEXT ){
					//add element to the TTU array
					tmpTTUElems.push(tokens[j].text);
				}
				//go to the next token
				j++;
			}	//end loop thru tokens to get elements of single TTU
			//make sure that the last token was closing angle bracket
			if( tokens[j].type != TOKEN_TYPE.GREATER ){
				//if current token is not '>', then this is not a TTU => skip
				continue;
			}
			//check if type has been added to the return variable
			if( tmpTypeName in ret ){
				//add entry for this type to the return variable
				ret[tmpTypeName] = [];
			}
			//add entry for the TTU
			ret[tmpTypeName].push(tmpTTUElems);
		}	//end if current token is '<'
	}	//end loop thru tokens
	return ret;
};