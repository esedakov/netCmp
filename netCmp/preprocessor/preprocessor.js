/**
	Developer:	Eduard Sedakov
	Date:		2016-01-15
	Description:	pre-process lexed code to identify all TTUs (Templated
					Type Usage = TTU) so that parser could create as many 
					templated types as there are use cases for such types.
					Example, if code has type 'foo' that takes two templates:
					code exmaple: 'object <_Ty,_Ky> foo { ... }'
					and inside code there are two various usage cases of 'foo'
					such as these: 'foo<int, real>' and 'foo<text, text>'
					then we would store two TTUs for type 'foo':
					1. <int, real>
					2. <text, text>
					and during parsing we would create two separate instances
					of type 'foo' for each mentioned TTU.
	Used by:		{parser}
	Dependencies:	{parser}, {lexer}
**/

//class pre-processor that is needed to find and store various TTUs
//input(s):
//	tokens: (Array<Token>) array of tokens generated by the lexer
function preprocessor(tokens){
	//initialize hashmap that would store types and associated array of TTUs
	this._typeTTUs = {};
	//ES 2016-07-31 (Issue 4, b_cmp_test_1): maintain set of template type identifiers (TTIs)
	this._typeTTIs = {};
	//store array of tokens
	this._tokens = tokens;
};	//end constructor for preprocessor

//process tokens to setup all TTUs
//input(s): (none)
//output(s):
//	(HashMap< string, Array<Array<text>> >) =>
//		hashmap's key (string) represents a name of templated type, e.g. 'foo'
//		hashmap's value stores two arrays:
//			outer array stores actual TTUs, while inner elements of each TTU
//Example for above: { 'foo' : { 'foo<int,real>' : ['int', 'real'], 'foo<text,text>' : ['text', 'text'] }}
preprocessor.prototype.processTTUs = function(){
	//loop thru tokens
	for( var i = 0; i < this._tokens.length; i++ ){
		//ES 2016-07-31 (Issue 4, b_cmp_test_1): is this a TTU (i.e. uses '<<')
		var isTTU = this._tokens[i].type == TOKEN_TYPE.TMPL_OPEN;
		//ES 2016-07-31 (Issue 4, b_cmp_test_1): is this a TTI (i.e. uses OBJECT '<')
		var isTTI = this._tokens[i].type == TOKEN_TYPE.LESS && 
					i > 0 && 
					this._tokens[i-1].type == TOKEN_TYPE.OBJECT;
		//determine if current token is an open angle bracket (i.e. '<<')
		if( (isTTU || isTTI) && i > 0 ){
			//what we need is an identifier before angle bracket
			//	which is the name of the type
			var tmpTypeToken = this._tokens[i-1];
			//make sure that type token is a TEXT
			//ES 2016-07-31 (Issue 4, b_cmp_test_1): narrow down condition to cover only TTU
			if( isTTU &&
				tmpTypeToken.type != TOKEN_TYPE.TEXT && 
				tmpTypeToken.type != TOKEN_TYPE.ARRAYTYPE &&
				tmpTypeToken.type != TOKEN_TYPE.BTREETYPE
			) {
				//skip, this is not a template definition => error in user code
				continue;
			}
			//ES 2016-07-31 (Issue 4, b_cmp_test_1): if it is a TTI
			if( isTTI ){
				//if token before '<' is not an OBJECT, then skip this case (error in user code)
				if( tmpTypeToken.type != TOKEN_TYPE.OBJECT ){
					//skip, this is not a template type identifier case
					continue;
				} else {	//if this is correct TTI configuration
					//reset
					tmpTypeToken = null;
					//it is a TTI, but we need to find object's name that goes after '>'
					//so, loop thru tokens until find a '>'
					for( var k = i; k < this._tokens.length; k++ ){
						//if iterated element is '>'
						if( this._tokens[k].type == TOKEN_TYPE.GREATER ){
							//then, next token is an object's name
							tmpTypeToken = this._tokens[k+1];
						}
					}
					//if have not found token for object's name
					if( tmpTypeToken == null ){
						//error
						throw new Error("cannot determine object's name for TTI case");
					}
				}	//end if token is '<'
			}	//ES 2016-07-31 (Issue 4, b_cmp_test_1): end if it is TTI
			//process template list
			var tmpRet = this.processTemplateList(i + 1);
			//reset index
			i = tmpRet.counter;
			//check if base type exists
			if( !(tmpTypeToken.text in this._typeTTUs) ){
				//ES 2016-07-31 (Issue 4, b_cmp_test_1): (original case) if it is TTU
				if( isTTU ){
					this._typeTTUs[tmpTypeToken.text] = {};
				} else {	//ES 2016-07-31 (Issue 4, b_cmp_test_1): if it is TTI, then init set of TTIs
					this._typeTTIs[tmpTypeToken.text] = {};
				}
			}
			//determine type name
			var tmpTypeName = tmpTypeToken.text + "<" + tmpRet.txt + ">";
			//check if type has been added to the return variable
			//ES 2016-07-31 (Issue 4, b_cmp_test_1): add case to check TTIs
			if( (isTTU && (tmpTypeName in this._typeTTUs[tmpTypeToken.text])) ||
				(isTTI && (tmpTypeName in this._typeTTIs[tmpTypeToken.text])) ) {
				//skip, this entry already exists
				continue;
			}
			//ES 2016-07-31 (Issue 4, b_cmp_test_1): if it is TTU
			if( isTTU ){
				//add entry for this TTU
				this._typeTTUs[tmpTypeToken.text][tmpTypeName] = tmpRet.tmpl;
			} else {	//ES 2016-07-31 (Issue 4, b_cmp_test_1): if it is TTI
				//add entry for this TTI
				this._typeTTIs[tmpTypeToken.text][tmpTypeName] = tmpRet.tmpl;
			}
		}	//end if current token is '<<' or '<'
	}	//end loop thru tokens
	//ES 2016-07-31 (Issue 4, b_cmp_test_1): now we need to loop thru TTIs and match with
	//	cases in TTUs, to remove those TTUs that are using template identifiers as their
	//	types, i.e. if they are both TTU and TTI
	for( var tmpCurTTIKey in this._typeTTIs ){
		//get TTI values
		var tmpTTIValues = this._typeTTIs[tmpCurTTIKey];
		//ensure that iterated TTI value is an object
		if( typeof tmpTTIValues == "object" ){
			//loop thru TTIs
			for( var tmpTTI in tmpTTIValues ){
				//if it is a case when TTI is also a TTU
				if( (tmpCurTTIKey in this._typeTTUs) && (tmpTTI in this._typeTTUs[tmpCurTTIKey]) ){
					//remove this TTU
					delete this._typeTTUs[tmpCurTTIKey][tmpTTI];
					//check if TTU sub-set is not empty
					if( jQuery.isEmptyObject(this._typeTTUs[tmpCurTTIKey]) ){
						//remove TTU sub-set
						delete this._typeTTUs[tmpCurTTIKey];
					}	//end if remove TTU sub-set
				}	//end if TTI is also TTU
			}	//end loop thru TTIs
		}	//end if it is TTI object
	}	//ES 2016-07-31 (Issue 4, b_cmp_test_1): end loop thru TTIs
	return this._typeTTUs;
};	//end function 'processTTUs'

//process template list, starting from the token passed '<<' or '<'
//input(s):
//	idx: (integer) => current index which points at the start of token 
//			list (i.e. after token '<<' or '<')
//output(s):
//	HashMap:
//		counter: (integer) => current index
//		txt: (text) text representation of types even templated types.
//			If we process foo<< goo<<int>>, real >> in this function,
//			then it should return following array: ['goo<int>', 'real']
//			Note: use single '<' and '>')
//		tmpl: (Array<text>) => array of strings representing templated types
preprocessor.prototype.processTemplateList = function(idx){
	//initialize array of type specifiers that are returned by this function
	var typeSpecArr = [];
	//initialize variable to keep concatenated string for all encountered tokens
	var txtRep = "";
	//temporary variable to keep track of last type specifier
	var tmpLastTypeId = null;
	//loop thru tokens starting from token pointed by index 'idx'
	//until the closing bracket for template list
	//ES 2016-07-31 (Issue 4, b_cmp_test_1): cover additional case for TTI (i.e. '>')
	while(  this._tokens[idx].type != TOKEN_TYPE.TMPL_CLOSE && 
			this._tokens[idx].type != TOKEN_TYPE.GREATER ){
		//get current token type
		var tmpTokenType = this._tokens[idx].type;
		//if find a start of template list
		//ES 2016-07-31 (Issue 4, b_cmp_test_1): cover additional case for TTU (i.e. '<')
		if( tmpTokenType == TOKEN_TYPE.TMPL_OPEN || tmpTokenType == TOKEN_TYPE.LESS ){
			//process template by calling recursively this function
			var tmpRes = this.processTemplateList(idx + 1);
			//remove type specifier from array
			tmpLastTypeId = typeSpecArr.pop();
			//compose template specifier
			var tmpTmpl = "<" + tmpRes.txt + ">";
			//add its result to the array of text specifiers
			typeSpecArr.push(tmpLastTypeId + tmpTmpl);
			//reset index
			idx = tmpRes.counter;
			//addup returned text representation of inner expression to this one
			txtRep += tmpTmpl;
			//compose full type name
			var tmpFullTypeName = tmpLastTypeId + tmpTmpl;
			//check if base type exists in library
			if( !(tmpLastTypeId in this._typeTTUs) ){
				this._typeTTUs[tmpLastTypeId] = {};
			}
			//check if this type has not been added to the set
			if( !(tmpFullTypeName in this._typeTTUs) ){
				//add type to the set
				this._typeTTUs[tmpLastTypeId][tmpFullTypeName] = tmpRes.tmpl;
			}
		//if this token is a text specifier for type
		} else if( tmpTokenType == TOKEN_TYPE.TEXT ||
				   tmpTokenType == TOKEN_TYPE.ARRAYTYPE ||
				   tmpTokenType == TOKEN_TYPE.BTREETYPE ) {
			//assing type specifier
			tmpLastTypeId = this._tokens[idx].text;
			//add type specifier to the text representation
			txtRep += tmpLastTypeId;
			//add new type specifier to the array
			typeSpecArr.push(tmpLastTypeId);
		//if this is a template type separator (i.e. ',')
		} else if( tmpTokenType == TOKEN_TYPE.COMMA ){
			//add comma to the text representation
			txtRep += ",";
			//reset last type specifier
			tmpLastTypeId = "";
		}	//end if find a start of template list
		//go to the next token
		idx++;
	}	//end loop thru tokens
	//return collection of counter and array of type specifiers
	return {counter: idx, tmpl: typeSpecArr, txt: txtRep};
};	//end function 'processTemplateList' to process template list